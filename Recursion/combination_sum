//So basically here we have used recursion, at each step we are following the step that is, picking up that element or not picking up. by making all the combination of the element whihc sum to the target.
// Time	
// ğ‘‚(2^ğ‘‡Ã—ğ‘›)
// Space (Stack)	
// ğ‘‚(ğ‘‡)
// Space (Result)	
// ğ‘‚(2^ğ‘‡Ã—ğ‘›)
// This analysis assumes worst-case scenarios. The actual complexity depends on the size of the candidates array, the target, and the pruning due to arr[idx]â‰¤target.


class Solution {
public:
   void findCombination(int idx, int target, vector<int>& arr, vector<vector<int>>& ans, vector<int> &ds){
          if(idx == arr.size()){
              if(target == 0){
                ans.push_back(ds);
              }
              return;
          }
          if(arr[idx]<= target){
            ds.push_back(arr[idx]);
            findCombination(idx,target-arr[idx], arr, ans,ds);
            ds.pop_back();
          }
          findCombination(idx+1, target, arr,ans, ds);
   }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> ans;
        vector<int> ds;
        findCombination(0,target, candidates, ans,ds);
        return ans;
    }
};
